extern VALUE rb_optimizer_realmatrix_reference_klass;
extern VALUE rb_optimizer_realmatrix_klass;
extern VALUE rb_optimizer_realvector_klass;

template<class Obtype>
VALUE method_matrix_get_sqrt (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	*(m->getData()) = sqrt(*(m->getData()));
	return self;
}

template<class Obtype>
VALUE method_matrix_to_ary (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return realmatrix_to_rb_ary(*(m->getData()));
}

template<class Obtype>
VALUE method_matrix_add (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(rb_other) == T_DATA) {
		// can also add two references together.
		if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_klass) {
			rb_RealMatrix *other;
			Data_Get_Struct(rb_other, rb_RealMatrix, other);
			if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + *(other->getData()))
					);
			} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + trans(*(other->getData())))
					);
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_klass) {
			rb_RealVector *other;
			Data_Get_Struct(rb_other, rb_RealVector, other);
			if (other->getData()->size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + *(other->getData())));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else if (other->getData()->size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + *(other->getData())));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + other)
					);
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + trans(other))
					);
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else if (other.size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else {
		rb_raise(rb_eArgError, "You can only add Arrays, RealVectors, and RealMatrices to a RealMatrix.");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_add_equals (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_klass) {
			rb_RealMatrix *other;
			Data_Get_Struct(rb_other, rb_RealMatrix, other);
			if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
				*(m->getData()) += *(other->getData());
			} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
				*(m->getData()) += trans(*(other->getData()));
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_reference_klass) {
			Obtype *other;
			Data_Get_Struct(rb_other, Obtype, other);
			if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
				*(m->getData()) += *(other->getData());
			} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
				*(m->getData()) += trans(*(other->getData()));
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_klass) {
			rb_RealVector *other;
			Data_Get_Struct(rb_other, rb_RealVector, other);
			if (other->getData()->size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + *(other->getData())));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else if (other->getData()->size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + *(other->getData())));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				*(m->getData()) += other;
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				*(m->getData()) += trans(other);
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else if (other.size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else {
		rb_raise(rb_eArgError, "You can only add Arrays, RealVectors, and RealMatrices to a RealMatrix.");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_multiply (VALUE self, VALUE multiplier) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(multiplier) == T_FLOAT || TYPE(multiplier) == T_FIXNUM) {
		return wrap_pointer<rb_RealMatrix>(
			rb_optimizer_realmatrix_klass,
			new rb_RealMatrix(*(m->getData()) * NUM2DBL(multiplier))
			);
	} else if (TYPE(multiplier) == T_DATA) {
		VALUE multiplier_klass = CLASS_OF(multiplier);
		if (multiplier_klass == rb_optimizer_realmatrix_klass) {
			rb_RealMatrix *multi_matrix;
			Data_Get_Struct(multiplier, rb_RealMatrix, multi_matrix);
			if (m->getData()->size2() != multi_matrix->getData()->size1()) {
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.", int(m->getData()->size2()), int(multi_matrix->getData()->size1()));
			}
			return wrap_pointer<rb_RealMatrix>(
				rb_optimizer_realmatrix_klass,
				new rb_RealMatrix(prod(*(m->getData()), *(multi_matrix->getData())))
				);
		}Â else if (multiplier_klass == rb_optimizer_realmatrix_reference_klass) {
			rb_RealMatrixReference *multi_matrix;
			Data_Get_Struct(multiplier, rb_RealMatrixReference, multi_matrix);
			if (m->getData()->size2() != multi_matrix->getData()->size1()) {
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.", int(m->getData()->size2()), int(multi_matrix->getData()->size1()));
			}
			return wrap_pointer<rb_RealMatrix>(
				rb_optimizer_realmatrix_klass,
				new rb_RealMatrix(prod(*(m->getData()), *(multi_matrix->getData())))
				);
		} else if (multiplier_klass == rb_optimizer_realvector_klass) {
			rb_RealVector *vec;
			Data_Get_Struct(multiplier, rb_RealVector, vec);
			if (m->getData()->size2() != vec->getData()->size()) {
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.", int(m->getData()->size2()), int(vec->getData()->size()));
			}
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(prod(*(m->getData()), *(vec->getData())))
				);
		} else {
			rb_raise(rb_eArgError, "Can only multiply RealMatrix by a scalar, RealMatrix, Array, or RealVector.");
		}
	} else if (TYPE(multiplier) == T_ARRAY) {
		if (RARRAY_LEN(multiplier) > 0 && TYPE(rb_ary_entry(multiplier, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(multiplier);
			if (m->getData()->size2() != multi_matrix.size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix.size1()).str().c_str());
			}/*
			RealMatrix temp(multi_matrix.size1(),m->getData()->size2());
			axpy_prod(*(m->getData()), multi_matrix, temp);*/
			return wrap_pointer<rb_RealMatrix>(
				rb_optimizer_realmatrix_klass,
				new rb_RealMatrix(prod(*(m->getData()), multi_matrix))
			);
		} else if (RARRAY_LEN(multiplier) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(multiplier);
			if (m->getData()->size2() != vec.size()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec.size()).str().c_str());
			}/*
			RealVector temp(m->getData()->size2());
			axpy_prod(*(m->getData()), vec, temp);*/
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(prod(*(m->getData()), vec))
			);
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty matrix since the computer's imagination is limited by the Kernel.");
		}
	} else {
		rb_raise(rb_eArgError, "Can only multiply RealMatrix by a scalar, RealMatrix, Array, or RealVector.");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_multiply_equals (VALUE self, VALUE multiplier) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(multiplier) == T_FLOAT || TYPE(multiplier) == T_FIXNUM) {
		*(m->getData()) *= NUM2DBL(multiplier);
	} else if (TYPE(multiplier) == T_DATA) {
		VALUE multiplier_klass = CLASS_OF(multiplier);
		if (multiplier_klass == rb_optimizer_realmatrix_klass) {
			rb_RealMatrix *multi_matrix;
			Data_Get_Struct(multiplier, rb_RealMatrix, multi_matrix);
			if (m->getData()->size2() != multi_matrix->getData()->size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix->getData()->size1()).str().c_str());
			}
			*(m->getData()) = prod(*(m->getData()), *(multi_matrix->getData()));
		} else if (multiplier_klass == rb_optimizer_realmatrix_reference_klass) {
			rb_RealMatrixReference *multi_matrix;
			Data_Get_Struct(multiplier, rb_RealMatrixReference, multi_matrix);
			if (m->getData()->size2() != multi_matrix->getData()->size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix->getData()->size1()).str().c_str());
			}
			*(m->getData()) = prod(*(m->getData()), *(multi_matrix->getData()));
		} else if (multiplier_klass == rb_optimizer_realvector_klass) {
			rb_RealVector *vec;
			Data_Get_Struct(multiplier, rb_RealVector, vec);
			if (m->getData()->size2() != vec->getData()->size()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec->getData()->size()).str().c_str());
			}
			RealMatrix temp_matrix(m->getData()->size1(), 1);
			column(temp_matrix, 0) = prod(*(m->getData()), *(vec->getData()));
			// might be a vector?
			*(m->getData()) = temp_matrix;
		} else {
			rb_raise(rb_eArgError, "Can only multiply RealMatrix by a scalar, RealMatrix, Array, or RealVector.");
		}
	} else if (TYPE(multiplier) == T_ARRAY) {
		if (RARRAY_LEN(multiplier) > 0 && TYPE(rb_ary_entry(multiplier, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(multiplier);
			if (m->getData()->size2() != multi_matrix.size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix.size1()).str().c_str());
			}
			/*RealMatrix temp(multi_matrix.size1(),m->getData()->size2());
			axpy_prod(*(m->getData()), multi_matrix, temp);*/
			*(m->getData()) = prod(*(m->getData()), multi_matrix);
		} else if (RARRAY_LEN(multiplier) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(multiplier);
			if (m->getData()->size2() != vec.size()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec.size()).str().c_str());
			}/*
			RealVector temp(m->getData()->size2());
			axpy_prod(*(m->getData()), vec, temp);*/
			RealMatrix temp_matrix(m->getData()->size1(), 1);
			column(temp_matrix, 0) = prod(*(m->getData()), vec);
			*(m->getData()) = temp_matrix;
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty matrix since the computer's imagination is limited by the Kernel.");
		}
	} else {
		rb_raise(rb_eArgError, "Can only multiply RealMatrix by a scalar, RealMatrix, Array, or RealVector.");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_divide (VALUE self, VALUE divider) {
	if (TYPE(divider) == T_FLOAT || TYPE(divider) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) /= NUM2DBL(divider);
	} else {
		rb_raise(rb_eArgError, "Can only divide RealMatrix by a number");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_length (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	VALUE size = rb_ary_new2(2);
	// number of rows
	rb_ary_store(size, 0, INT2FIX(m->getData()->size1()));
	// number of columns
	rb_ary_store(size, 1, INT2FIX(m->getData()->size2()));
	return size;
}

template<class Obtype>
VALUE method_matrix_transpose (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(trans(*(m->getData())))
		);
}

template<class Obtype>
VALUE method_matrix_size1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size1());
}

template<class Obtype>
VALUE method_matrix_size2 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size2());
}

template<class Obtype>
VALUE method_matrix_stride1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride1());
}

template<class Obtype>
VALUE method_matrix_stride2 (VALUE self) {
	Check_Type(index, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride2());
}

template<class Obtype>
VALUE method_matrix_get_row (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index);

	if (index < 0 && int(index + m->getData()->size2()) < 0)
		rb_raise(rb_eArgError, "Out of range of RealMatrix");
	if (index >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range of RealMatrix");

	return wrap_pointer<rb_RealVector>(
		rb_optimizer_realvector_klass,
		new rb_RealVector(row(*(m->getData()),
			index < 0 ?
				index + m->getData()->size2() :
				index
			))
		);
}

template<class Obtype>
VALUE method_matrix_get_column (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index),
		neg_index = 0;

	if (index < neg_index && (index + int(m->getData()->size1()) < neg_index))
		rb_raise(rb_eArgError, "Out of range of RealMatrix");
	if (index >= int(m->getData()->size1()))
		rb_raise(rb_eArgError, "Out of range of RealMatrix");

	return wrap_pointer<rb_RealVector>(
		rb_optimizer_realvector_klass,
		new rb_RealVector(column(*(m->getData()),
			index < 0 ?
				index + m->getData()->size2() :
				index
			))
		);
}

template<class Obtype>
VALUE method_matrix_clear (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->clear();
	return self;
}

template<class Obtype>
VALUE method_matrix_fill (VALUE self, VALUE filling) {
	if (TYPE(filling) != T_FLOAT && TYPE(filling) != T_FIXNUM)
		rb_raise(rb_eArgError, "Can only fill RealMatrix with floats.");
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	std::fill(m->getData()->storage(), m->getData()->storage()+(m->getData()->size1()*(m->getData()->size2())), NUM2DBL(filling));

	return self;
}

template<class Obtype>
VALUE method_matrix_query (VALUE self, VALUE row, VALUE column) {
	Check_Type(row, T_FIXNUM);
	Check_Type(column, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	int neg_index = 0;
	if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions in RealMatrix");
	if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range of RealMatrix");
	return rb_float_new((*(m->getData()))(NUM2INT(row), NUM2INT(column)));
}

template<class Obtype>
VALUE method_matrix_insert (VALUE self, VALUE row, VALUE column, VALUE assignment) {
	Check_Type(row, T_FIXNUM);
	Check_Type(column, T_FIXNUM);
	if (TYPE(assignment) != T_FIXNUM && TYPE(assignment) != T_FLOAT)
		rb_raise(rb_eArgError, "Can only insert floats into RealMatrix.");

	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	int neg_index = 0;
	if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions in RealMatrix");
	if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range of RealMatrix");
	(*(m->getData()))(NUM2INT(row), NUM2INT(column)) = NUM2DBL(assignment);
	return self;
}

template<class Obtype>
VALUE method_matrix_resize (VALUE self, VALUE newRows, VALUE newColumns) {
	Check_Type(newRows, T_FIXNUM);
	Check_Type(newColumns, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->resize(NUM2INT(newRows), NUM2INT(newColumns));
	return self;
}

template<class Obtype>
VALUE method_matrix_negate (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(-*(m->getData()))
	);
}

template<class Obtype>
VALUE method_matrix_to_realvectors (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	std::vector<RealVector> vectors = realmatrix_to_stdvector_realvector(*(m->getData()));

	return stdvector_realvector_to_rb_ary_of_realvectors(vectors);
}

template<class Obtype>
VALUE method_matrix_initialize_copy(VALUE rb_copy, VALUE rb_orig) {
	Obtype *orig;
	Obtype *copy;
	if (rb_copy == rb_orig)
		return rb_copy;
	Check_Type(rb_orig, T_DATA);
	Data_Get_Struct(rb_orig, Obtype, orig);
	Data_Get_Struct(rb_copy, Obtype, copy);
	copy->data = orig->data;

	return rb_copy;
}

template<class Obtype>
VALUE method_realmatrix_reference_deep_copy(VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(*(m->getData()))
		);
}

template<class Obtype>
void Init_MatrixMethods (VALUE klass) {

	rb_define_method(klass, "initialize_copy", (rb_method)method_matrix_initialize_copy<Obtype>, 0);
	rb_define_method(klass, "deep_copy", (rb_method)method_realmatrix_reference_deep_copy<Obtype>, 0);
	rb_define_method(klass, "sqrt", (rb_method)method_matrix_get_sqrt<Obtype>,0);
	rb_define_method(klass, "to_a", (rb_method)method_matrix_to_ary<Obtype>, 0);
	rb_define_method(klass, "to_realvectors", (rb_method)method_matrix_to_realvectors<Obtype>, 0);
	rb_define_method(klass, "*", (rb_method)method_matrix_multiply<Obtype>, 1);
	rb_define_method(klass, "*=", (rb_method)method_matrix_multiply_equals, 1);
	rb_define_method(klass, "/", (rb_method)method_matrix_divide<Obtype>, 1);
	rb_define_method(klass, "+", (rb_method)method_matrix_add<Obtype>, 1);
	rb_define_method(klass, "+=", (rb_method)method_matrix_add_equals<Obtype>, 1);
	rb_define_method(klass, "length", (rb_method)method_matrix_length<Obtype>, 0);
	rb_define_method(klass, "size", (rb_method)method_matrix_length<Obtype>, 0);
	rb_define_method(klass, "transpose", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(klass, "~", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(klass, "size1", (rb_method)method_matrix_size1<Obtype>, 0);
	rb_define_method(klass, "size2", (rb_method)method_matrix_size2<Obtype>, 0);
	rb_define_method(klass, "stride1", (rb_method)method_matrix_stride1<Obtype>, 0);
	rb_define_method(klass, "stride2", (rb_method)method_matrix_stride2<Obtype>, 0);
	rb_define_method(klass, "row", (rb_method)method_matrix_get_row<Obtype>, 1);
	rb_define_method(klass, "column", (rb_method)method_matrix_get_column<Obtype>, 1);
	rb_define_method(klass, "col", (rb_method)method_matrix_get_column<Obtype>, 1);
	rb_define_method(klass, "fill", (rb_method)method_matrix_fill<Obtype>, 1);
	rb_define_method(klass, "clear", (rb_method)method_matrix_clear<Obtype>, 0);
	rb_define_method(klass, "-@", (rb_method)method_matrix_negate<Obtype>,0);
	rb_define_method(klass, "[]", (rb_method)method_matrix_query<Obtype>,2);
	rb_define_method(klass, "resize", (rb_method)method_matrix_resize<Obtype>, 2);
	rb_define_method(klass, "[]=", (rb_method)method_matrix_insert<Obtype>,3);

}