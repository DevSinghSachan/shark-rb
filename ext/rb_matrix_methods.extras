extern VALUE rb_optimizer_realmatrix_reference_klass;
extern VALUE rb_optimizer_realmatrix_klass;
extern VALUE rb_optimizer_realvector_klass;
extern VALUE rb_optimizer_realvector_reference_klass;
extern VALUE rb_optimizer_realmatrix_row_klass;
extern VALUE rb_optimizer_realmatrix_column_klass;

template<class Obtype>
VALUE method_matrix_get_sqrt (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	*(m->getData()) = sqrt(*(m->getData()));
	return self;
}

template<class Obtype>
VALUE method_matrix_to_ary (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return realmatrix_to_rb_ary(*(m->getData()));
}

template<class matType, class Obtype>
static VALUE add_matrix_with_matrix(Obtype* m, VALUE adder) {
	matType *other;
	Data_Get_Struct(adder, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_optimizer_realmatrix_klass,
			new rb_RealMatrix(*(m->getData()) + *(other->getData()))
			);
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_optimizer_realmatrix_klass,
			new rb_RealMatrix(*(m->getData()) + trans(*(other->getData())))
			);
	} else {
		rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
	}
	return Qnil;
}

template<class vectorType, class Obtype>
static VALUE add_matrix_with_vector(Obtype* m, VALUE adder) {
	vectorType *other;
	Data_Get_Struct(adder, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		if (m->getData()->size2() == 1) {
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(column(*(m->getData()), 0) + *(other->getData())));
		} else {
			rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
		}
	} else if (other->getData()->size() == m->getData()->size2()) {
		if (m->getData()->size1() == 1) {
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(row(*(m->getData()), 0) + *(other->getData())));
		} else {
			rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
		}
	} else {
		rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
	}
	return Qnil;
}

template<class Obtype>
VALUE method_matrix_add (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(rb_other) == T_DATA) {
		// can also add two references together.
		if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_klass) {
			return add_matrix_with_matrix<rb_RealMatrix>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_reference_klass) {
			return add_matrix_with_matrix<rb_RealMatrixReference>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_klass) {
			return add_matrix_with_vector<rb_RealVector>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_reference_klass) {
			return add_matrix_with_vector<rb_RealVectorReference>(m, rb_other);
		} else {
			rb_raise(rb_eArgError, "You can only add Arrays, RealVectors, and RealMatrices to a %s.", rb_obj_classname(self));
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + other)
					);
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_optimizer_realmatrix_klass,
					new rb_RealMatrix(*(m->getData()) + trans(other))
					);
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and %s suffer from incompatible dimensions.", rb_obj_classname(self));
				}
			} else if (other.size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and %s suffer from incompatible dimensions.", rb_obj_classname(self));
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else {
		rb_raise(rb_eArgError, "You can only add Arrays, RealVectors, and RealMatrices to a %s.", rb_obj_classname(self));
	}
	return self;
}

template<class matType, class Obtype>
static VALUE add_equals_matrix_with_matrix(Obtype* m, VALUE adder) {
	matType *other;
	Data_Get_Struct(adder, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		*(m->getData()) += *(other->getData());
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		*(m->getData()) += trans(*(other->getData()));
	} else {
		rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
	}
	return Qnil;
}

template<class vectorType, class Obtype>
static VALUE add_equals_matrix_with_vector(Obtype* m, VALUE adder) {
	vectorType *other;
	Data_Get_Struct(adder, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		if (m->getData()->size2() == 1) {
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(column(*(m->getData()), 0) + *(other->getData())));
		} else {
			rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
		}
	} else if (other->getData()->size() == m->getData()->size2()) {
		if (m->getData()->size1() == 1) {
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(row(*(m->getData()), 0) + *(other->getData())));
		} else {
			rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
		}
	} else {
		rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
	}
	return Qnil;
}


template<class Obtype>
VALUE method_matrix_add_equals (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_klass) {
			return add_equals_matrix_with_matrix<rb_RealMatrix>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realmatrix_reference_klass) {
			return add_equals_matrix_with_matrix<rb_RealMatrixReference>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_klass) {
			return add_equals_matrix_with_vector<rb_RealVector>(m, rb_other);
		} else if (CLASS_OF(rb_other) == rb_optimizer_realvector_reference_klass) {
			return add_equals_matrix_with_vector<rb_RealVector>(m, rb_other);
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				*(m->getData()) += other;
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				*(m->getData()) += trans(other);
			} else {
				rb_raise(rb_eArgError, "The Matrices you are summing don't have the same dimensions, so their sum is infeasible using our current (human) technology.");
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				if (m->getData()->size2() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(row(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and %s suffer from incompatible dimensions.", rb_obj_classname(self));
				}
			} else if (other.size() == m->getData()->size2()) {
				if (m->getData()->size1() == 1) {
					return wrap_pointer<rb_RealVector>(
						rb_optimizer_realvector_klass,
						new rb_RealVector(column(*(m->getData()), 0) + other));
				} else {
					rb_raise(rb_eArgError, "The RealVector and RealMatrix suffer from incompatible dimensions.");
				}
			} else {
				rb_raise(rb_eArgError, "The RealVector you are adding doesn't have the same dimensions as either RealMatrix dimension, so their sum is infeasible using our current (human) technology.");
			}
		}
	} else {
		rb_raise(rb_eArgError, "You can only add Arrays, RealVectors, and RealMatrices to a %s.", rb_obj_classname(self));
	}
	return self;
}

template<class vectorType, class Obtype>
static VALUE multiply_matrix_with_vector(Obtype* m, VALUE multiplier) {
	vectorType *vec;
	Data_Get_Struct(multiplier, vectorType, vec);
	if (m->getData()->size2() != vec->getData()->size()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.", int(m->getData()->size2()), int(vec->getData()->size()));
	}
	return wrap_pointer<rb_RealVector>(
		rb_optimizer_realvector_klass,
		new rb_RealVector(prod(*(m->getData()), *(vec->getData())))
		);
}
template<class matType, class Obtype>
static VALUE multiply_matrix_with_matrix(Obtype* m, VALUE multiplier) {
	matType *multi_matrix;
	Data_Get_Struct(multiplier, matType, multi_matrix);
	if (m->getData()->size2() != multi_matrix->getData()->size1()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.", int(m->getData()->size2()), int(multi_matrix->getData()->size1()));
	}
	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(prod(*(m->getData()), *(multi_matrix->getData())))
		);
}

template<class Obtype>
VALUE method_matrix_multiply (VALUE self, VALUE multiplier) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(multiplier) == T_FLOAT || TYPE(multiplier) == T_FIXNUM) {
		return wrap_pointer<rb_RealMatrix>(
			rb_optimizer_realmatrix_klass,
			new rb_RealMatrix(*(m->getData()) * NUM2DBL(multiplier))
			);
	} else if (TYPE(multiplier) == T_DATA) {
		VALUE multiplier_klass = CLASS_OF(multiplier);
		if (multiplier_klass == rb_optimizer_realmatrix_klass) {
			return multiply_matrix_with_matrix<rb_RealMatrix>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realmatrix_reference_klass) {
			return multiply_matrix_with_matrix<rb_RealMatrixReference>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realvector_klass) {
			return multiply_matrix_with_vector<rb_RealVector>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realvector_reference_klass) {
			return multiply_matrix_with_vector<rb_RealVectorReference>(m, multiplier);
		} else {
			rb_raise(rb_eArgError, "Can only multiply %s by a scalar, RealMatrix, Array, or RealVector.", rb_obj_classname(self));
		}
	} else if (TYPE(multiplier) == T_ARRAY) {
		if (RARRAY_LEN(multiplier) > 0 && TYPE(rb_ary_entry(multiplier, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(multiplier);
			if (m->getData()->size2() != multi_matrix.size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix.size1()).str().c_str());
			}
			return wrap_pointer<rb_RealMatrix>(
				rb_optimizer_realmatrix_klass,
				new rb_RealMatrix(prod(*(m->getData()), multi_matrix))
			);
		} else if (RARRAY_LEN(multiplier) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(multiplier);
			if (m->getData()->size2() != vec.size()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec.size()).str().c_str());
			}
			return wrap_pointer<rb_RealVector>(
				rb_optimizer_realvector_klass,
				new rb_RealVector(prod(*(m->getData()), vec))
			);
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		rb_raise(rb_eArgError, "Can only multiply %s by a scalar, RealMatrix, Array, or RealVector.", rb_obj_classname(self));
	}
	return self;
}

template<class vectorType, class Obtype>
static VALUE multiply_equals_matrix_with_vector(Obtype* m, VALUE multiplier) {
	vectorType *vec;
	Data_Get_Struct(multiplier, vectorType, vec);
	if (m->getData()->size2() != vec->getData()->size()) {
		boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
		rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec->getData()->size()).str().c_str());
	}
	RealMatrix temp_matrix(m->getData()->size1(), 1);
	column(temp_matrix, 0) = prod(*(m->getData()), *(vec->getData()));
	*(m->getData()) = temp_matrix;
}

template<class matType, class Obtype>
static void multiply_equals_matrix_with_matrix(Obtype* m, VALUE multiplier) {
	matType *multi_matrix;
	Data_Get_Struct(multiplier, matType, multi_matrix);
	if (m->getData()->size2() != multi_matrix->getData()->size1()) {
		boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
		rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix->getData()->size1()).str().c_str());
	}
	*(m->getData()) = prod(*(m->getData()), *(multi_matrix->getData()));
}

template<class Obtype>
VALUE method_matrix_multiply_equals (VALUE self, VALUE multiplier) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (TYPE(multiplier) == T_FLOAT || TYPE(multiplier) == T_FIXNUM) {
		*(m->getData()) *= NUM2DBL(multiplier);
	} else if (TYPE(multiplier) == T_DATA) {
		VALUE multiplier_klass = CLASS_OF(multiplier);
		if (multiplier_klass == rb_optimizer_realmatrix_klass) {
			multiply_equals_matrix_with_matrix<rb_RealMatrix>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realmatrix_reference_klass) {
			multiply_equals_matrix_with_matrix<rb_RealMatrixReference>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realvector_klass) {
			multiply_equals_matrix_with_vector<rb_RealVector>(m, multiplier);
		} else if (multiplier_klass == rb_optimizer_realvector_reference_klass) {
			multiply_equals_matrix_with_vector<rb_RealVectorReference>(m, multiplier);
		} else {
			rb_raise(rb_eArgError, "Can only multiply %s by a scalar, RealMatrix, Array, or RealVector.", rb_obj_classname(self));
		}
	} else if (TYPE(multiplier) == T_ARRAY) {
		if (RARRAY_LEN(multiplier) > 0 && TYPE(rb_ary_entry(multiplier, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(multiplier);
			if (m->getData()->size2() != multi_matrix.size1()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % multi_matrix.size1()).str().c_str());
			}
			*(m->getData()) = prod(*(m->getData()), multi_matrix);
		} else if (RARRAY_LEN(multiplier) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(multiplier);
			if (m->getData()->size2() != vec.size()) {
				boost::format error_str("For matrix product A*B incompatible number of A columns (%d) and B rows (%d) for multiplication.");
				rb_raise(rb_eArgError, (error_str % m->getData()->size2() % vec.size()).str().c_str());
			}
			RealMatrix temp_matrix(m->getData()->size1(), 1);
			column(temp_matrix, 0) = prod(*(m->getData()), vec);
			*(m->getData()) = temp_matrix;
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		rb_raise(rb_eArgError, "Can only multiply %s by a scalar, RealMatrix, Array, or RealVector.", rb_obj_classname(self));
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_divide (VALUE self, VALUE divider) {
	if (TYPE(divider) == T_FLOAT || TYPE(divider) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) /= NUM2DBL(divider);
	} else {
		rb_raise(rb_eArgError, "Can only divide %s by a number", rb_obj_classname(self));
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_length (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	VALUE size = rb_ary_new2(2);
	// number of rows
	rb_ary_store(size, 0, INT2FIX(m->getData()->size1()));
	// number of columns
	rb_ary_store(size, 1, INT2FIX(m->getData()->size2()));
	return size;
}

template<class Obtype>
VALUE method_matrix_transpose (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(trans(*(m->getData())))
		);
}

template<class Obtype>
VALUE method_matrix_size1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size1());
}

template<class Obtype>
VALUE method_matrix_size2 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size2());
}

template<class Obtype>
VALUE method_matrix_stride1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride1());
}

template<class Obtype>
VALUE method_matrix_stride2 (VALUE self) {
	Check_Type(index, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride2());
}

template<class Obtype>
VALUE method_matrix_get_row (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index);

	if (index < 0 && int(index + m->getData()->size2()) < 0)
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
	if (index >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));

	return wrap_pointer<rb_RealMatrixRow>(
		rb_optimizer_realmatrix_row_klass,
		new rb_RealMatrixRow(m->getData(),
			index < 0 ?
				index + m->getData()->size2() :
				index
			)
		);
}

template<class Obtype>
VALUE method_matrix_get_column (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index),
		neg_index = 0;

	if (index < neg_index && (index + int(m->getData()->size1()) < neg_index))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
	if (index >= int(m->getData()->size1()))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));

	return wrap_pointer<rb_RealMatrixColumn>(
		rb_optimizer_realmatrix_column_klass,
		new rb_RealMatrixColumn(m->getData(),
			index < 0 ?
				index + m->getData()->size1() :
				index
			)
		);
	return Qnil;
}

template<class Obtype>
VALUE method_matrix_clear (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->clear();
	return self;
}

template<class Obtype>
VALUE method_matrix_fill (VALUE self, VALUE filling) {
	if (TYPE(filling) != T_FLOAT && TYPE(filling) != T_FIXNUM)
		rb_raise(rb_eArgError, "Can only fill %s with floats.", rb_obj_classname(self));
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	std::fill(m->getData()->storage(), m->getData()->storage()+(m->getData()->size1()*(m->getData()->size2())), NUM2DBL(filling));

	return self;
}

template<class Obtype>
VALUE method_matrix_query (int number_of_arguments, VALUE* ruby_arguments, VALUE self) {
	VALUE row, column;
	rb_scan_args(number_of_arguments, ruby_arguments, "11", &row, &column);
	if (column != Qnil && row != Qnil) {
		Check_Type(row, T_FIXNUM);
		Check_Type(column, T_FIXNUM);
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		int neg_index = 0;
		if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
			rb_raise(rb_eArgError, "Can only access positive positions in %s", rb_obj_classname(self));
		if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
			rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
		return rb_float_new((*(m->getData()))(NUM2INT(row), NUM2INT(column)));
	} else {
		if (TYPE(row) == T_FIXNUM) {
			return method_matrix_get_row<Obtype>(self, row);
		} else if (row == Qnil && TYPE(column) == T_FIXNUM) {
			return method_matrix_get_column<Obtype>(self, column);
		} else {
			rb_raise(rb_eArgError, "Can only access %s using 1. [Fixnum, Fixnum], or 2. [Nil, Fixnum], or 3. [Fixnum].", rb_obj_classname(self));
		}
	}
}

template<class Obtype>
static void method_matrix_insert_row(Obtype *m, int _row, VALUE assignment) {
	int neg_index = 0;
	if (_row < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions.");
	if (_row >= int(m->getData()->size1()))
		rb_raise(rb_eArgError, "Out of range.");

	if (TYPE(assignment) == T_DATA) {
		if (CLASS_OF(assignment) == rb_optimizer_realvector_klass) {
			rb_RealVector *v;
			Data_Get_Struct(assignment, rb_RealVector, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realvector_reference_klass) {
			rb_RealVectorReference *v;
			Data_Get_Struct(assignment, rb_RealVectorReference, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realmatrix_row_klass) {
			rb_RealMatrixRow *v;
			Data_Get_Struct(assignment, rb_RealMatrixRow, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realmatrix_column_klass) {
			rb_RealMatrixColumn *v;
			Data_Get_Struct(assignment, rb_RealMatrixColumn, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else {
			rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
		}
	} else if (TYPE(assignment) == T_ARRAY) {
		if (RARRAY_LEN(assignment) != m->getData()->size2())
			rb_raise(rb_eArgError, "Can only assign a new row of equal size to previous row length.");
		if (RARRAY_LEN(assignment) > 0) {
			if (TYPE(rb_ary_entry(assignment, 0)) != T_FIXNUM && TYPE(rb_ary_entry(assignment, 0)) != T_FLOAT)
				rb_raise(rb_eArgError, "Can only insert floats.");
			RealVector vec = rb_ary_to_1d_realvector(assignment);
			row(*(m->getData()), _row) = vec;
		}
	} else {
		rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
	}
}

template<class Obtype>
static void method_matrix_insert_column (Obtype *m, int col, VALUE assignment) {
	int neg_index = 0;
	if (col < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions.");
	if (col >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range.");


	if (TYPE(assignment) == T_DATA) {
		if (CLASS_OF(assignment) == rb_optimizer_realvector_klass) {
			rb_RealVector *v;
			Data_Get_Struct(assignment, rb_RealVector, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realvector_reference_klass) {
			rb_RealVectorReference *v;
			Data_Get_Struct(assignment, rb_RealVectorReference, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realmatrix_row_klass) {
			rb_RealMatrixRow *v;
			Data_Get_Struct(assignment, rb_RealMatrixRow, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_optimizer_realmatrix_column_klass) {
			rb_RealMatrixColumn *v;
			Data_Get_Struct(assignment, rb_RealMatrixColumn, v);
			column(*(m->getData()), col) = *(v->getData());
		} else {
			rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
		}
	} else if (TYPE(assignment) == T_ARRAY) {
		if (RARRAY_LEN(assignment) != int(m->getData()->size1()))
			rb_raise(rb_eArgError, "Can only assign a new column of equal size to previous column length.");
		if (RARRAY_LEN(assignment) > 0) {
			if (TYPE(rb_ary_entry(assignment, 0)) != T_FIXNUM && TYPE(rb_ary_entry(assignment, 0)) != T_FLOAT)
				rb_raise(rb_eArgError, "Can only insert floats.");
			RealVector vec = rb_ary_to_1d_realvector(assignment);
			column(*(m->getData()), col) = vec;
		}
	} else {
		rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
	}
}

template<class Obtype>
VALUE method_matrix_insert (int number_of_arguments, VALUE* ruby_arguments, VALUE self) {
	VALUE row, column, assignment;

	rb_scan_args(number_of_arguments, ruby_arguments, "21", &row, &column, &assignment);

	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (assignment != Qnil && row != Qnil) {
		Check_Type(row, T_FIXNUM);
		Check_Type(column, T_FIXNUM);
		if (TYPE(assignment) != T_FIXNUM && TYPE(assignment) != T_FLOAT)
			rb_raise(rb_eArgError, "Can only insert floats into %s.", rb_obj_classname(self));
		int neg_index = 0;
		if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
			rb_raise(rb_eArgError, "Can only access positive positions in %s", rb_obj_classname(self));
		if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
			rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
		(*(m->getData()))(NUM2INT(row), NUM2INT(column)) = NUM2DBL(assignment);
	} else {
		// assigning a row or column.
		if (TYPE(row) == T_FIXNUM && column != Qnil && assignment == Qnil) {
			method_matrix_insert_row<Obtype>(m, NUM2INT(row), column);
		} else if (row == Qnil && TYPE(column) == T_FIXNUM && assignment != Qnil) {
			method_matrix_insert_column<Obtype>(m, NUM2INT(column), assignment);
		} else {
			rb_raise(rb_eArgError, "Can only make assignments using:\\\t1. [Fixnum, Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn] or\\\t2.[Nil, Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn], or\\\t3.[Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn],\\with  %s.", rb_obj_classname(self));
		}
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_resize (VALUE self, VALUE newRows, VALUE newColumns) {
	Check_Type(newRows, T_FIXNUM);
	Check_Type(newColumns, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->resize(NUM2INT(newRows), NUM2INT(newColumns));
	return self;
}

template<class Obtype>
VALUE method_matrix_negate (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(-*(m->getData()))
	);
}

template<class Obtype>
VALUE method_matrix_to_rows (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	//std::vector<rb_RealMatrixRow> vectors = realmatrix_to_stdvector_realvector(m->getData());
	VALUE ary = rb_ary_new2(int(m->getData()->size1()));
	for (size_t i=0; i< m->getData()->size1(); i++) {
		rb_ary_store(ary, (int)i, wrap_pointer<rb_RealMatrixRow>(
			rb_optimizer_realmatrix_row_klass,
			new rb_RealMatrixRow(m->getData(), i)
		));
	}
	return ary;
}

template<class Obtype>
VALUE method_matrix_to_columns (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	//std::vector<rb_RealMatrixRow> vectors = realmatrix_to_stdvector_realvector(m->getData());
	VALUE ary = rb_ary_new2(int(m->getData()->size2()));
	for (size_t i=0; i< m->getData()->size2(); i++) {
		rb_ary_store(ary, (int)i, wrap_pointer<rb_RealMatrixColumn>(
			rb_optimizer_realmatrix_column_klass,
			new rb_RealMatrixColumn(m->getData(), i)
		));
	}
	return ary;
}

template<class Obtype>
VALUE method_matrix_initialize_copy(VALUE rb_copy, VALUE rb_orig) {
	Obtype *orig;
	Obtype *copy;
	if (rb_copy == rb_orig)
		return rb_copy;
	Check_Type(rb_orig, T_DATA);
	Data_Get_Struct(rb_orig, Obtype, orig);
	Data_Get_Struct(rb_copy, Obtype, copy);
	copy->data = orig->data;

	return rb_copy;
}

template<class Obtype>
VALUE method_matrix_deep_copy(VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	return wrap_pointer<rb_RealMatrix>(
		rb_optimizer_realmatrix_klass,
		new rb_RealMatrix(*(m->getData()))
		);
}

template<class Obtype, class OtherObtype>
VALUE method_matrix_compare(VALUE left, VALUE right) {
	Obtype *v;
	OtherObtype *other_v;
	Data_Get_Struct(left, Obtype, v);
	Data_Get_Struct(right, OtherObtype, other_v);
	// check size
	if (other_v->getData()->size1() != v->getData()->size1() || other_v->getData()->size2() != v->getData()->size2())
		return Qfalse;
	// check each element... can parallelize this.
	for (size_t i = 0; i<v->getData()->size1(); i++)
		for (size_t j = 0; j<v->getData()->size2(); j++)
			if ((*(other_v->getData()))(i,j) != (*(v->getData()))(i,j))
				return Qfalse;
	return Qtrue;
}

template<class Obtype>
VALUE method_matrix_soft_eql(VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		VALUE other_class = CLASS_OF(rb_other);
		if (other_class == rb_optimizer_realmatrix_klass) {
			return method_matrix_compare<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (other_class == rb_optimizer_realvector_reference_klass) {
			return method_matrix_compare<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else {
			return Qfalse;
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		VALUE self_ary = method_matrix_to_ary<Obtype>(self);
		return rb_funcall(self_ary, rb_intern("=="), 1, rb_other);
	} else {
		return Qfalse;
	}
}

template<class Obtype>
VALUE method_matrix_eql(VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) != CLASS_OF(self))
			return Qfalse;
		return method_matrix_compare<Obtype, Obtype>(self, rb_other);
	} else {
		return Qfalse;
	}
}

template<class Obtype>
void Init_MatrixMethods (VALUE klass) {

	rb_define_method(klass, "initialize_copy", (rb_method)method_matrix_initialize_copy<Obtype>, 1);
	rb_define_method(klass, "deep_copy", (rb_method)method_matrix_deep_copy<Obtype>, 0);
	rb_define_method(klass, "sqrt", (rb_method)method_matrix_get_sqrt<Obtype>,0);
	rb_define_method(klass, "to_a", (rb_method)method_matrix_to_ary<Obtype>, 0);
	rb_define_method(klass, "rows", (rb_method)method_matrix_to_rows<Obtype>, 0);
	rb_define_method(klass, "columns", (rb_method)method_matrix_to_columns<Obtype>,0);
	rb_define_method(klass, "cols", (rb_method)method_matrix_to_columns<Obtype>,0);
	rb_define_method(klass, "*", (rb_method)method_matrix_multiply<Obtype>, 1);
	rb_define_method(klass, "*=", (rb_method)method_matrix_multiply_equals<Obtype>, 1);
	rb_define_method(klass, "/", (rb_method)method_matrix_divide<Obtype>, 1);
	rb_define_method(klass, "+", (rb_method)method_matrix_add<Obtype>, 1);
	rb_define_method(klass, "+=", (rb_method)method_matrix_add_equals<Obtype>, 1);
	rb_define_method(klass, "length", (rb_method)method_matrix_length<Obtype>, 0);
	rb_define_method(klass, "==", (rb_method) method_matrix_soft_eql<Obtype>,1);
	rb_define_method(klass, "eql?", (rb_method) method_matrix_eql<Obtype>,1);
	rb_define_alias(klass, "size", "length");
	rb_define_method(klass, "transpose", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(klass, "~", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(klass, "size1", (rb_method)method_matrix_size1<Obtype>, 0);
	rb_define_method(klass, "size2", (rb_method)method_matrix_size2<Obtype>, 0);
	rb_define_method(klass, "stride1", (rb_method)method_matrix_stride1<Obtype>, 0);
	rb_define_method(klass, "stride2", (rb_method)method_matrix_stride2<Obtype>, 0);
	rb_define_method(klass, "row", (rb_method)method_matrix_get_row<Obtype>, 1);
	rb_define_method(klass, "column", (rb_method)method_matrix_get_column<Obtype>, 1);
	rb_define_method(klass, "col", (rb_method)method_matrix_get_column<Obtype>, 1);
	rb_define_method(klass, "fill", (rb_method)method_matrix_fill<Obtype>, 1);
	rb_define_method(klass, "clear", (rb_method)method_matrix_clear<Obtype>, 0);
	rb_define_method(klass, "-@", (rb_method)method_matrix_negate<Obtype>,0);
	rb_define_method(klass, "[]", (rb_method)method_matrix_query<Obtype>,-1);
	rb_define_method(klass, "resize", (rb_method)method_matrix_resize<Obtype>, 2);
	rb_define_method(klass, "[]=", (rb_method)method_matrix_insert<Obtype>,-1);

}