#include "../utils/rb_datatype_deep_copy.extras"

template<class Obtype>
static void binaryoperation_format_error(char* msg) {
	rb_raise(rb_eArgError, "You can only %s Scalars, Arrays, RealVectors, RealMatrices, RealMatrixRows, RealMatrixColumns and numbers to a %s.", *msg, rb_class2name(Obtype::rb_class()));
}

template<class Obtype>
static shark::RealMatrix round(Obtype & _mat) {

    shark::RealMatrix _rounded(_mat);
    
    for (size_t i = 0; i < _rounded.size1(); i++)
    	for (size_t j = 0; j < _rounded.size2(); j++)
	        _rounded(i,j) = round(_rounded(i,j));
    return _rounded;
}

template<class Obtype>
VALUE method_matrix_get_rounded (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(round(*(m->getData())))
			);

}


template<class Obtype>
VALUE method_matrix_get_sqrt (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(sqrt(*(m->getData())))
			);
}

template<class Obtype, class otherType>
VALUE method_matrix_matrid_hadamard_product (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	otherType *other;
	Data_Get_Struct(rb_other, otherType, other);

	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) * *(other->getData()))
		);
	} else {
		rb_raise(rb_eArgError, "The %s you are hadamard producting don't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_class2name(otherType::rb_class()), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_each (VALUE self) {

	RETURN_SIZED_ENUMERATOR_PRE
	RETURN_SIZED_ENUMERATOR(self, 0, 0);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
		for (size_t i = 0; i< m->getData()->size1();i++) {
			rb_yield(wrap_pointer<rb_RealMatrixRow>(
					rb_RealMatrixRow::rb_class(),
					new rb_RealMatrixRow(m->getData(), i)
				)
			);
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_each_column (VALUE self) {

	RETURN_SIZED_ENUMERATOR_PRE
	RETURN_SIZED_ENUMERATOR(self, 0, 0);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
		for (size_t i = 0; i< m->getData()->size2();i++) {
			rb_yield(wrap_pointer<rb_RealMatrixColumn>(
					rb_RealMatrixColumn::rb_class(),
					new rb_RealMatrixColumn(m->getData(), i)
				)
			);
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_each_with_index (VALUE self) {
	RETURN_SIZED_ENUMERATOR_PRE
	RETURN_SIZED_ENUMERATOR(self, 0, 0);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
		for (size_t i = 0; i< m->getData()->size1();i++) {
			rb_yield_values(2, 
				wrap_pointer<rb_RealMatrixRow>(
					rb_RealMatrixRow::rb_class(),
					new rb_RealMatrixRow(m->getData(), i)
				),
				INT2FIX(i)
			);
	}
	return self;
}

template<class Obtype, class otherType>
VALUE method_matrix_matrid_hadamard_product_equals (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	otherType *other;
	Data_Get_Struct(rb_other, otherType, other);

	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		*(m->getData()) *= *(other->getData());
		return self;
	} else {
		rb_raise(rb_eArgError, "The %s you are hadamard producting don't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_class2name(otherType::rb_class()), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_hadamard_product (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return method_matrix_matrid_hadamard_product<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return method_matrix_matrid_hadamard_product<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else {
			rb_raise(rb_eArgError, "To perform a Hadamard product use a RealMatrix, a RealMatrixReference, or an Array");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		RealMatrix other = rb_ary_to_realmatrix(rb_other);
		if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
			return wrap_pointer<rb_RealMatrix>(
				rb_RealMatrix::rb_class(),
				new rb_RealMatrix(*(m->getData()) * other)
			);
		} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
			return wrap_pointer<rb_RealMatrix>(
				rb_RealMatrix::rb_class(),
				new rb_RealMatrix(*(m->getData()) * trans(other))
			);
		} else {
			rb_raise(rb_eArgError, "The %s you are hadamard producting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
		}
	} else {
		rb_raise(rb_eArgError, "To perform a Hadamard product use a RealMatrix, a RealMatrixReference, or an Array");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_hadamard_product_equals (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return method_matrix_matrid_hadamard_product_equals<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return method_matrix_matrid_hadamard_product_equals<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else {
			rb_raise(rb_eArgError, "To perform a Hadamard product use a RealMatrix, a RealMatrixReference, or an Array");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		RealMatrix other = rb_ary_to_realmatrix(rb_other);
		if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
			*(m->getData()) *= other;
		} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
			*(m->getData()) *= trans(other);
		} else {
			rb_raise(rb_eArgError, "The %s you are hadamard producting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
		}
	} else {
		rb_raise(rb_eArgError, "To perform a Hadamard product use a RealMatrix, a RealMatrixReference, or an Array");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_get_exp (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(exp(*(m->getData())))
			);
}

template<class Obtype>
VALUE sum_matrix_rows (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_sum(m->getData()->size1());
	for (size_t i=0;i< m->getData()->size1(); i++) {
		directed_sum(i) = sum(row(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_sum)
		);
}

template<class Obtype>
VALUE sum_matrix_columns (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_sum(m->getData()->size2());
	for (size_t i=0;i< m->getData()->size2(); i++) {
		directed_sum(i) = sum(column(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_sum)
		);
}

template<class Obtype>
static void method_matrix_get_sum_input_error() {
	rb_raise(rb_eArgError, "To sum a %s you can: \n\t-specify a direction using symbols: :columns, or :rows\n\t-specify a direction for the axis: 0 or 1,\n\t-specify a hash with an axis or direction field that is either a Fixnum (1 or 0) or a Symbol (:columns or :rows).", rb_class2name(Obtype::rb_class()));
}

template<class Obtype>
VALUE method_matrix_get_sum_non_overloaded(VALUE self, VALUE direction) {
	if (TYPE(direction) == T_SYMBOL) {
		if (direction == rb_sym_new("rows")) {
			return sum_matrix_rows<Obtype>(self);
		} else if (direction == rb_sym_new("columns")) {
			return sum_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_sum_input_error<Obtype>();
		}
	} else if (TYPE(direction) == T_FIXNUM) {
		if (NUM2INT(direction) == 1) {
			return sum_matrix_rows<Obtype>(self);
		} else if (NUM2INT(direction) == 0) {
			return sum_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_sum_input_error<Obtype>();
		}
	} else if (direction == Qnil) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return rb_float_new(sum(*(m->getData())));
	} else {
		method_matrix_get_sum_input_error<Obtype>();
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_get_sum (int number_of_arguments, VALUE * ruby_arguments, VALUE self) {
	VALUE direction = Qnil;
	rb_scan_args(number_of_arguments, ruby_arguments, "01", &direction);

	if (TYPE(direction) == T_HASH) {
		VALUE hash_direction = rb_hash_aref(direction, rb_sym_new("axis"));
		if (hash_direction == Qnil) {
			hash_direction = rb_hash_aref(direction, rb_sym_new("direction"));
		}
		return method_matrix_get_sum_non_overloaded<Obtype>(self, hash_direction);
	} else {
		return method_matrix_get_sum_non_overloaded<Obtype>(self, direction);
	}
	return self;
}

template<class Obtype>
VALUE max_matrix_rows (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_max(m->getData()->size1());
	for (size_t i=0;i< m->getData()->size1(); i++) {
		directed_max(i) = max(row(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_max)
		);
}

template<class Obtype>
VALUE max_matrix_columns (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_max(m->getData()->size2());
	for (size_t i=0;i< m->getData()->size2(); i++) {
		directed_max(i) = max(column(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_max)
		);
}

template<class Obtype>
static double calculate_matrix_max(Obtype& _mat) {
	double _max = -std::numeric_limits<double>::infinity();
	for (size_t i=0;i<_mat.size1();i++) {
		double new_max = max(row(_mat, i));
		_max = new_max > _max ? new_max : _max;
	}
	return _max;
}

template<class Obtype>
static double calculate_matrix_min(Obtype& _mat) {
	double _min = std::numeric_limits<double>::infinity();
	for (size_t i=0;i<_mat.size1();i++) {
		double new_min = min(row(_mat, i));
		_min = new_min < _min ? new_min : _min;
	}
	return _min;
}

template<class Obtype>
static void method_matrix_get_max_input_error() {
	rb_raise(rb_eArgError, "To obtain the max of a %s you can: \n\t-specify a direction using symbols: :columns, or :rows\n\t-specify a direction for the axis: 0 or 1,\n\t-specify a hash with an axis or direction field that is either a Fixnum (1 or 0) or a Symbol (:columns or :rows).", rb_class2name(Obtype::rb_class()));
}

template<class Obtype>
VALUE method_matrix_get_max_non_overloaded(VALUE self, VALUE direction) {
	if (TYPE(direction) == T_SYMBOL) {
		if (direction == rb_sym_new("rows")) {
			return max_matrix_rows<Obtype>(self);
		} else if (direction == rb_sym_new("columns")) {
			return max_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_max_input_error<Obtype>();
		}
	} else if (TYPE(direction) == T_FIXNUM) {
		if (NUM2INT(direction) == 1) {
			return max_matrix_rows<Obtype>(self);
		} else if (NUM2INT(direction) == 0) {
			return max_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_max_input_error<Obtype>();
		}
	} else if (direction == Qnil) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return (m->getData()->size1() > 0 && m->getData()->size2() > 0) ? rb_float_new(calculate_matrix_max<>(*(m->getData()))) : Qnil;
	} else {
		method_matrix_get_max_input_error<Obtype>();
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_get_max (int number_of_arguments, VALUE * ruby_arguments, VALUE self) {
	VALUE direction = Qnil;
	rb_scan_args(number_of_arguments, ruby_arguments, "01", &direction);

	if (TYPE(direction) == T_HASH) {
		VALUE hash_direction = rb_hash_aref(direction, rb_sym_new("axis"));
		if (hash_direction == Qnil) {
			hash_direction = rb_hash_aref(direction, rb_sym_new("direction"));
		}
		return method_matrix_get_max_non_overloaded<Obtype>(self, hash_direction);
	} else {
		return method_matrix_get_max_non_overloaded<Obtype>(self, direction);
	}
	return self;
}

template<class Obtype>
VALUE min_matrix_rows (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_min(m->getData()->size1());
	for (size_t i=0;i< m->getData()->size1(); i++) {
		directed_min(i) = min(row(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_min)
		);
}

template<class Obtype>
VALUE min_matrix_columns (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	RealVector directed_min(m->getData()->size2());
	for (size_t i=0;i< m->getData()->size2(); i++) {
		directed_min(i) = min(column(*(m->getData()), i));
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(directed_min)
		);
}

template<class Obtype>
static void method_matrix_get_min_input_error() {
	rb_raise(rb_eArgError, "To obtain the min of a %s you can: \n\t-specify a direction using symbols: :columns, or :rows\n\t-specify a direction for the axis: 0 or 1,\n\t-specify a hash with an axis or direction field that is either a Fixnum (1 or 0) or a Symbol (:columns or :rows).", rb_class2name(Obtype::rb_class()));
}

template<class Obtype>
VALUE method_matrix_get_min_non_overloaded(VALUE self, VALUE direction) {
	if (TYPE(direction) == T_SYMBOL) {
		if (direction == rb_sym_new("rows")) {
			return min_matrix_rows<Obtype>(self);
		} else if (direction == rb_sym_new("columns")) {
			return min_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_min_input_error<Obtype>();
		}
	} else if (TYPE(direction) == T_FIXNUM) {
		if (NUM2INT(direction) == 1) {
			return min_matrix_rows<Obtype>(self);
		} else if (NUM2INT(direction) == 0) {
			return min_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_min_input_error<Obtype>();
		}
	} else if (direction == Qnil) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return (m->getData()->size1() > 0 && m->getData()->size2() > 0) ? rb_float_new(calculate_matrix_min<>(*(m->getData()))) : Qnil;
	} else {
		method_matrix_get_min_input_error<Obtype>();
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_get_min (int number_of_arguments, VALUE * ruby_arguments, VALUE self) {
	VALUE direction = Qnil;
	rb_scan_args(number_of_arguments, ruby_arguments, "01", &direction);

	if (TYPE(direction) == T_HASH) {
		VALUE hash_direction = rb_hash_aref(direction, rb_sym_new("axis"));
		if (hash_direction == Qnil) {
			hash_direction = rb_hash_aref(direction, rb_sym_new("direction"));
		}
		return method_matrix_get_min_non_overloaded<Obtype>(self, hash_direction);
	} else {
		return method_matrix_get_min_non_overloaded<Obtype>(self, direction);
	}
	return self;
}

template<class Obtype>
static Obtype log(Obtype & _mat) {

	Obtype _log_mat = _mat;

	for (size_t i=0;i < _mat.size1();i++)
		for (size_t j=0;j < _mat.size2();j++)
			_log_mat(i,j) = std::log(_mat(i,j));

	return _log_mat;
}

template<class Obtype>
VALUE method_matrix_get_log (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(log<>(*(m->getData())))
			);
}

template<class Obtype>
static double mean(Obtype& m) {
	double total(0.0);
	for (size_t i = 0 ; i< m.size(); i++)
		total += m[i];
	if (m.size() > 0)
		total /= m.size();
	return total;
}

template<class Obtype>
static void method_matrix_get_mean_input_error() {
	rb_raise(rb_eArgError, "To obtain the mean of %s you can: \n\t-specify a direction using symbols: :columns, or :rows\n\t-specify a direction for the axis: 0 or 1,\n\t-specify a hash with an axis or direction field that is either a Fixnum (1 or 0) or a Symbol (:columns or :rows).", rb_class2name(Obtype::rb_class()));
}

template<class Obtype>
VALUE mean_matrix_rows(VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	RealVector means(m->getData()->size1());

	for (size_t i = 0 ; i< m->getData()->size1(); i++) {
		shark::blas::matrix_row<RealMatrix> _slice(*(m->getData()), i);
		means[i] = mean<shark::blas::matrix_row<RealMatrix> >(_slice);
	}

	return wrap_pointer<rb_RealVector>(
			rb_RealVector::rb_class(),
			new rb_RealVector(means)
			);
}

template<class Obtype>
VALUE mean_matrix_columns(VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	RealVector means(m->getData()->size2());

	for (size_t i = 0 ; i< m->getData()->size2(); i++) {
		shark::blas::matrix_column<RealMatrix> _slice(*(m->getData()), i);
		means[i] = mean<shark::blas::matrix_column<RealMatrix> >(_slice);
	}

	return wrap_pointer<rb_RealVector>(
			rb_RealVector::rb_class(),
			new rb_RealVector(means)
			);
}

template<class Obtype>
static double calculate_matrix_mean(Obtype& _mat) {
	double total = 0.0;
	for (size_t i = 0;i<_mat.size1();i++)
		for (size_t j = 0;j<_mat.size2();j++)
			total += _mat(i,j);
	return (_mat.size1() > 0 && _mat.size2()) ? (total / double(_mat.size1() * _mat.size2())) : total;
}

template<class Obtype>
VALUE method_matrix_get_mean_non_overloaded(VALUE self, VALUE direction) {
	if (TYPE(direction) == T_SYMBOL) {
		if (direction == rb_sym_new("rows")) {
			return mean_matrix_rows<Obtype>(self);
		} else if (direction == rb_sym_new("columns")) {
			return mean_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_mean_input_error<Obtype>();
		}
	} else if (TYPE(direction) == T_FIXNUM) {
		if (NUM2INT(direction) == 1) {
			return mean_matrix_rows<Obtype>(self);
		} else if (NUM2INT(direction) == 0) {
			return mean_matrix_columns<Obtype>(self);
		} else {
			method_matrix_get_mean_input_error<Obtype>();
		}
	} else if (direction == Qnil) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return rb_float_new(calculate_matrix_mean<>(*(m->getData())));
	} else {
		method_matrix_get_mean_input_error<Obtype>();
	}
	return self;
}


template<class Obtype>
VALUE method_matrix_get_mean (int number_of_arguments, VALUE * ruby_arguments, VALUE self) {
	VALUE direction = Qnil;
	rb_scan_args(number_of_arguments, ruby_arguments, "01", &direction);

	if (TYPE(direction) == T_HASH) {
		VALUE hash_direction = rb_hash_aref(direction, rb_sym_new("axis"));
		if (hash_direction == Qnil) {
			hash_direction = rb_hash_aref(direction, rb_sym_new("direction"));
		}
		return method_matrix_get_mean_non_overloaded<Obtype>(self, hash_direction);
	} else {
		return method_matrix_get_mean_non_overloaded<Obtype>(self, direction);
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_get_inverse (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(shark::blas::pow(*(m->getData()),-1))
			);
}

template<class Obtype>
VALUE method_matrix_get_pow (VALUE self, VALUE rb_pow) {
	if (TYPE(rb_pow) != T_FLOAT && TYPE(rb_pow) != T_FIXNUM)
		rb_raise(rb_eArgError, "This matrix can only be raised to a power by a scalar.");
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(shark::blas::pow(*(m->getData()),NUM2DBL(rb_pow)))
			);
}

template<class Obtype>
VALUE method_matrix_to_ary (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return realmatrix_to_rb_ary(*(m->getData()));
}

template<class Obtype>
VALUE method_matrix_to_matrix (VALUE self) {
	Obtype *s;
	Data_Get_Struct(self, Obtype, s);
	if (Obtype::rb_class() == rb_RealMatrix::rb_class()) {
		return self;
	} else {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(s->getData()))
			);
	}
}

template<class Obtype>
VALUE method_matrix_to_unlabeleddata (VALUE self) {
    Obtype *m;
    Data_Get_Struct(self, Obtype, m);

    std::vector<RealVector > elements(m->getData()->size1());

    for (size_t i=0; i< m->getData()->size1(); i++)
        elements[i] = row(*(m->getData()), i);

    return wrap_pointer<rb_UnlabeledData>(
        rb_UnlabeledData::rb_class(),
        new rb_UnlabeledData(shark::createDataFromRange(elements))
    );
}

template<class Obtype, class matType>
static VALUE add_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *other;
	Data_Get_Struct(rb_other, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) + *(other->getData()))
			);
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) + trans(*(other->getData())))
			);
	} else {
		rb_raise(rb_eArgError, "The %s you are summing doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype, class vectorType>
static VALUE add_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *other;
	Data_Get_Struct(rb_other, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) + trans(shark::blas::repeat(*(other->getData()), m->getData()->size2())))
		);
	} else if (other->getData()->size() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) + shark::blas::repeat(*(other->getData()), m->getData()->size1()))
		);
	} else {
		rb_raise(rb_eArgError, "The %s you are summing doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype, class matType>
static VALUE subtract_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *other;
	Data_Get_Struct(rb_other, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) - *(other->getData()))
			);
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) - trans(*(other->getData())))
			);
	} else {
		rb_raise(rb_eArgError, "The %s you are substracting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype, class vectorType>
static VALUE subtract_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *other;
	Data_Get_Struct(rb_other, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) - trans(shark::blas::repeat(*(other->getData()), m->getData()->size2())))
		);
	} else if (other->getData()->size() == m->getData()->size2()) {
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) - shark::blas::repeat(*(other->getData()), m->getData()->size1()))
		);
	} else {
		rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype>
VALUE method_matrix_add (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		// can also add two references together.
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return add_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return add_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVector::rb_class()) {
			return add_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVectorReference::rb_class()) {
			return add_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixRow::rb_class()) {
			return add_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixColumn::rb_class()) {
			return add_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("add");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) + other)
					);
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) + trans(other))
					);
			} else {
				rb_raise(rb_eArgError, "The %s you are adding doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		} else {
			Obtype *m;
			Data_Get_Struct(self, Obtype, m);
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				return wrap_pointer<rb_RealMatrix>(
						rb_RealMatrix::rb_class(),
						new rb_RealMatrix(*(m->getData()) + shark::blas::repeat(other, m->getData()->size2()))
						);
			} else if (other.size() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
						rb_RealMatrix::rb_class(),
						new rb_RealMatrix(*(m->getData()) + trans(shark::blas::repeat(other, m->getData()->size1())))
					);
			} else {
				rb_raise(rb_eArgError, "The %s you are adding doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		}
	} else if (TYPE(rb_other) == T_FIXNUM || TYPE(rb_other) == T_FLOAT) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) + blas::repeat(NUM2DBL(rb_other), m->getData()->size1(), m->getData()->size2()))
					);
	} else {
		binaryoperation_format_error<Obtype>("add");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_subtract (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		// can also add two references together.
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return subtract_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return subtract_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVector::rb_class()) {
			return subtract_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVectorReference::rb_class()) {
			return subtract_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixRow::rb_class()) {
			return subtract_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixColumn::rb_class()) {
			return subtract_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("subtract");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) - other)
					);
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) - trans(other))
					);
			} else {
				rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				return wrap_pointer<rb_RealMatrix>(
						rb_RealMatrix::rb_class(),
						new rb_RealMatrix(*(m->getData()) - shark::blas::repeat(other, m->getData()->size2()))
						);
			} else if (other.size() == m->getData()->size2()) {
				return wrap_pointer<rb_RealMatrix>(
						rb_RealMatrix::rb_class(),
						new rb_RealMatrix(*(m->getData()) - trans(shark::blas::repeat(other, m->getData()->size1())))
					);
			} else {
				rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		}
	} else if (TYPE(rb_other) == T_FIXNUM || TYPE(rb_other) == T_FLOAT) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return wrap_pointer<rb_RealMatrix>(
					rb_RealMatrix::rb_class(),
					new rb_RealMatrix(*(m->getData()) + blas::repeat(NUM2DBL(rb_other), m->getData()->size1(), m->getData()->size2()))
					);
	} else {
		binaryoperation_format_error<Obtype>("subtract");
	}
	return self;
}

template<class Obtype, class matType>
static VALUE add_equals_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *other;
	Data_Get_Struct(rb_other, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		*(m->getData()) += *(other->getData());
		return self;
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		*(m->getData()) += trans(*(other->getData()));
		return self;
	} else {
		rb_raise(rb_eArgError, "The %s you are adding doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype, class vectorType>
static VALUE add_equals_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *other;
	Data_Get_Struct(rb_other, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		*(m->getData()) += trans(shark::blas::repeat(*(other->getData()), m->getData()->size2()));
		return self;
	} else if (other->getData()->size() == m->getData()->size2()) {
		*(m->getData()) += shark::blas::repeat(*(other->getData()), m->getData()->size1());
		return self;
	} else {
		rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return self;
}

template<class Obtype, class matType>
static VALUE subtract_equals_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *other;
	Data_Get_Struct(rb_other, matType, other);
	if (other->getData()->size1() == m->getData()->size1() && other->getData()->size2() == m->getData()->size2()) {
		*(m->getData()) -= *(other->getData());
		return self;
	} else if (other->getData()->size2() == m->getData()->size1() && other->getData()->size1() == m->getData()->size2()) {
		*(m->getData()) -= trans(*(other->getData()));
		return self;
	} else {
		rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size1(), other->getData()->size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return self;
}

template<class Obtype, class vectorType>
static VALUE subtract_equals_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *other;
	Data_Get_Struct(rb_other, vectorType, other);
	if (other->getData()->size() == m->getData()->size1()) {
		*(m->getData()) -= trans(shark::blas::repeat(*(other->getData()), m->getData()->size2()));
		return self;
	} else if (other->getData()->size() == m->getData()->size2()) {
		*(m->getData()) -= shark::blas::repeat(*(other->getData()), m->getData()->size1());
		return self;
	} else {
		rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other->getData()->size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
	}
	return Qnil;
}

template<class Obtype>
VALUE method_matrix_add_equals (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return add_equals_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return add_equals_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVector::rb_class()) {
			return add_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVectorReference::rb_class()) {
			return add_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixRow::rb_class()) {
			return add_equals_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixColumn::rb_class()) {
			return add_equals_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("add");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				*(m->getData()) += other;
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				*(m->getData()) += trans(other);
			} else {
				rb_raise(rb_eArgError, "The %s you are summing doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				*(m->getData()) += shark::blas::repeat(other, m->getData()->size2());
			} else if (other.size() == m->getData()->size2()) {
				*(m->getData()) += trans(shark::blas::repeat(other, m->getData()->size1()));
			} else {
				rb_raise(rb_eArgError, "The %s you are summing doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		}
	} else if (TYPE(rb_other) == T_FIXNUM || TYPE(rb_other) == T_FLOAT) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) += blas::repeat(NUM2DBL(rb_other), m->getData()->size1(), m->getData()->size2());
	} else {
		binaryoperation_format_error<Obtype>("add");
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_subtract_equals (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) == rb_RealMatrix::rb_class()) {
			return subtract_equals_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixReference::rb_class()) {
			return subtract_equals_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVector::rb_class()) {
			return subtract_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealVectorReference::rb_class()) {
			return subtract_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixRow::rb_class()) {
			return subtract_equals_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (CLASS_OF(rb_other) == rb_RealMatrixColumn::rb_class()) {
			return subtract_equals_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("subtract");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix other = rb_ary_to_realmatrix(rb_other);
			if (other.size1() == m->getData()->size1() && other.size2() == m->getData()->size2()) {
				*(m->getData()) -= other;
			} else if (other.size2() == m->getData()->size1() && other.size1() == m->getData()->size2()) {
				*(m->getData()) -= trans(other);
			} else {
				rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu x %lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size1(), other.size2(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		} else {
			RealVector other = rb_ary_to_1d_realvector(rb_other);
			if (other.size() == m->getData()->size1()) {
				*(m->getData()) -= shark::blas::repeat(other, m->getData()->size2());
			} else if (other.size() == m->getData()->size2()) {
				*(m->getData()) -= trans(shark::blas::repeat(other, m->getData()->size1()));
			} else {
				rb_raise(rb_eArgError, "The %s you are subtracting doesn't have the same dimensions (%lu) vs (%lu x %lu) as either %s dimension, so their sum is infeasible using our current (human) technology.", rb_obj_classname(rb_other), other.size(), m->getData()->size1(), m->getData()->size2(), rb_class2name(Obtype::rb_class()));
			}
		}
	} else if (TYPE(rb_other) == T_FIXNUM || TYPE(rb_other) == T_FLOAT) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) -= blas::repeat(NUM2DBL(rb_other), m->getData()->size1(), m->getData()->size2());
	} else {
		binaryoperation_format_error<Obtype>("subtract");
	}
	return self;
}

template<class Obtype, class vectorType>
static VALUE multiply_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *vec;
	Data_Get_Struct(rb_other, vectorType, vec);
	if (m->getData()->size2() != vec->getData()->size()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), vec->getData()->size());
	}
	return wrap_pointer<rb_RealVector>(
		rb_RealVector::rb_class(),
		new rb_RealVector(prod(*(m->getData()), *(vec->getData())))
		);
}
template<class Obtype, class matType>
static VALUE multiply_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *multi_matrix;
	Data_Get_Struct(rb_other, matType, multi_matrix);
	if (m->getData()->size2() != multi_matrix->getData()->size1()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), multi_matrix->getData()->size1());
	}
	return wrap_pointer<rb_RealMatrix>(
		rb_RealMatrix::rb_class(),
		new rb_RealMatrix(prod(*(m->getData()), *(multi_matrix->getData())))
		);
}

template<class Obtype>
VALUE method_matrix_multiply (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_FLOAT || TYPE(rb_other) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) * NUM2DBL(rb_other))
			);
	} else if (TYPE(rb_other) == T_DATA) {
		VALUE rb_other_klass = CLASS_OF(rb_other);
		if (rb_other_klass == rb_RealMatrix::rb_class()) {
			return multiply_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixReference::rb_class()) {
			return multiply_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (rb_other_klass == rb_RealVector::rb_class()) {
			return multiply_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (rb_other_klass == rb_RealVectorReference::rb_class()) {
			return multiply_matrix_with_vector<Obtype, rb_RealVectorReference>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixRow::rb_class()) {
			return multiply_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixColumn::rb_class()) {
			return multiply_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("multiply");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(rb_other);
			if (m->getData()->size2() != multi_matrix.size1())
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), multi_matrix.size1());
			return wrap_pointer<rb_RealMatrix>(
				rb_RealMatrix::rb_class(),
				new rb_RealMatrix(prod(*(m->getData()), multi_matrix))
			);
		} else if (RARRAY_LEN(rb_other) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(rb_other);
			if (m->getData()->size2() != vec.size())
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), vec.size());
			return wrap_pointer<rb_RealVector>(
				rb_RealVector::rb_class(),
				new rb_RealVector(prod(*(m->getData()), vec))
			);
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		binaryoperation_format_error<Obtype>("multiply");
	}
	return self;
}
// replace by fast_prod ?
template<class Obtype, class vectorType>
static VALUE multiply_equals_matrix_with_vector(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *vec;
	Data_Get_Struct(rb_other, vectorType, vec);
	if (m->getData()->size2() != vec->getData()->size()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), vec->getData()->size());
	}
	RealMatrix temp_matrix(m->getData()->size1(), 1);
	column(temp_matrix, 0) = prod(*(m->getData()), *(vec->getData()));
	*(m->getData()) = temp_matrix;
}

template<class Obtype, class matType>
static void multiply_equals_matrix_with_matrix(VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *multi_matrix;
	Data_Get_Struct(rb_other, matType, multi_matrix);
	if (m->getData()->size2() != multi_matrix->getData()->size1()) {
		rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), multi_matrix->getData()->size1());
	}
	*(m->getData()) = prod(*(m->getData()), *(multi_matrix->getData()));
}

template<class Obtype>
VALUE method_matrix_multiply_equals (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_FLOAT || TYPE(rb_other) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) *= NUM2DBL(rb_other);
	} else if (TYPE(rb_other) == T_DATA) {
		VALUE rb_other_klass = CLASS_OF(rb_other);
		if (rb_other_klass == rb_RealMatrix::rb_class()) {
			multiply_equals_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixReference::rb_class()) {
			multiply_equals_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (rb_other_klass == rb_RealVector::rb_class()) {
			multiply_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (rb_other_klass == rb_RealVectorReference::rb_class()) {
			multiply_equals_matrix_with_vector<Obtype, rb_RealVectorReference>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixRow::rb_class()) {
			multiply_equals_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (rb_other_klass == rb_RealMatrixColumn::rb_class()) {
			multiply_equals_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			binaryoperation_format_error<Obtype>("multiply");
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix multi_matrix = rb_ary_to_realmatrix(rb_other);
			if (m->getData()->size2() != multi_matrix.size1())
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), multi_matrix.size1());
			*(m->getData()) = prod(*(m->getData()), multi_matrix);
		} else if (RARRAY_LEN(rb_other) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(rb_other);
			if (m->getData()->size2() != vec.size())
				rb_raise(rb_eArgError, "For matrix product A*B incompatible number of A columns (%lu) and B rows (%lu) for multiplication.", m->getData()->size2(), vec.size());
			RealMatrix temp_matrix(m->getData()->size1(), 1);
			column(temp_matrix, 0) = prod(*(m->getData()), vec);
			*(m->getData()) = temp_matrix;
		} else {
			rb_raise(rb_eArgError, "It is tough to multiply by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		binaryoperation_format_error<Obtype>("multiply");
	}
	return self;
}

template<class Obtype, class vectorType>
VALUE divide_matrix_with_vector (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *v;
	Data_Get_Struct(rb_other, vectorType, v);

	return wrap_pointer<rb_RealMatrix>(
		rb_RealMatrix::rb_class(),
		new rb_RealMatrix(*(m->getData()) / shark::blas::repeat(*(v->getData()), m->getData()->size1()))
	);
}

template<class Obtype>
static void divide_warning_compatibility () {
	rb_raise(rb_eArgError, "Can only divide %s by a scalar, or ArrayType (\"RealVector\", \"RealVector\", \"RealMatrixColumn\", \"RealMatrixRow\", \"Array\"), or MatrixType (\"RealMatrix\", \"RealMatrixReference\").", rb_class2name(Obtype::rb_class()));
}

template<class Obtype, class matType>
VALUE divide_matrix_with_matrix (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *v;
	Data_Get_Struct(rb_other, matType, v);

	if (v->getData()->size1() != m->getData()->size1() || v->getData()->size2() != m->getData()->size2())
		rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B columns (%lu) or A rows (%lu) and B rows (%lu)for division.", m->getData()->size2(), v->getData()->size2(), m->getData()->size1(), v->getData()->size1());

	return wrap_pointer<rb_RealMatrix>(
		rb_RealMatrix::rb_class(),
		new rb_RealMatrix(*(m->getData()) / *(v->getData()))
	);
}

template<class Obtype>
VALUE method_matrix_divide (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_FLOAT || TYPE(rb_other) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		return wrap_pointer<rb_RealMatrix>(
			rb_RealMatrix::rb_class(),
			new rb_RealMatrix(*(m->getData()) / NUM2DBL(rb_other))
			);
	} else if (TYPE(rb_other) == T_DATA) {
		VALUE divider_klass = CLASS_OF(rb_other);
		if (divider_klass == rb_RealMatrix::rb_class()) {
			return divide_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixReference::rb_class()) {
			return divide_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (divider_klass == rb_RealVector::rb_class()) {
			return divide_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (divider_klass == rb_RealVectorReference::rb_class()) {
			return divide_matrix_with_vector<Obtype, rb_RealVectorReference>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixRow::rb_class()) {
			return divide_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixColumn::rb_class()) {
			return divide_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			divide_warning_compatibility<Obtype>();
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix division_matrix = rb_ary_to_realmatrix(rb_other);
			Obtype *m;
			Data_Get_Struct(self, Obtype, m);
			if (m->getData()->size2() != division_matrix.size1())
				rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B rows (%lu) for division.", m->getData()->size2(), division_matrix.size1());
			return wrap_pointer<rb_RealMatrix>(
				rb_RealMatrix::rb_class(),
				new rb_RealMatrix(*(m->getData()) / division_matrix)
			);
		} else if (RARRAY_LEN(rb_other) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(rb_other);
			Obtype *m;
			Data_Get_Struct(self, Obtype, m);
			if (m->getData()->size2() != vec.size())
				rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B rows (%lu) for division.", m->getData()->size2(), vec.size());
			return wrap_pointer<rb_RealMatrix>(
				rb_RealMatrix::rb_class(),
				new rb_RealMatrix(*(m->getData()) / shark::blas::repeat(vec, m->getData()->size1()))
			);
		} else {
			rb_raise(rb_eArgError, "It is tough to divide by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		divide_warning_compatibility<Obtype>();
	}
}

template<class Obtype, class vectorType>
VALUE divide_equals_matrix_with_vector (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	vectorType *v;
	Data_Get_Struct(rb_other, vectorType, v);

	*(m->getData()) /= shark::blas::repeat(*(v->getData()), m->getData()->size1());
	return self;
}

template<class Obtype, class matType>
VALUE divide_equals_matrix_with_matrix (VALUE self, VALUE rb_other) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	matType *v;
	Data_Get_Struct(rb_other, matType, v);

	if (v->getData()->size1() != m->getData()->size1() || v->getData()->size2() != m->getData()->size2())
		rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B columns (%lu) or A rows (%lu) and B rows (%lu)for division.", m->getData()->size2(), v->getData()->size2(), m->getData()->size1(), v->getData()->size1());

	*(m->getData()) /= *(v->getData());
	return self;
}

template<class Obtype>
VALUE method_matrix_divide_equals (VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_FLOAT || TYPE(rb_other) == T_FIXNUM) {
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		*(m->getData()) /= NUM2DBL(rb_other);
		return self;
	} else if (TYPE(rb_other) == T_DATA) {
		VALUE divider_klass = CLASS_OF(rb_other);
		if (divider_klass == rb_RealMatrix::rb_class()) {
			return divide_equals_matrix_with_matrix<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixReference::rb_class()) {
			return divide_equals_matrix_with_matrix<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else if (divider_klass == rb_RealVector::rb_class()) {
			return divide_equals_matrix_with_vector<Obtype, rb_RealVector>(self, rb_other);
		} else if (divider_klass == rb_RealVectorReference::rb_class()) {
			return divide_equals_matrix_with_vector<Obtype, rb_RealVectorReference>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixRow::rb_class()) {
			return divide_equals_matrix_with_vector<Obtype, rb_RealMatrixRow>(self, rb_other);
		} else if (divider_klass == rb_RealMatrixColumn::rb_class()) {
			return divide_equals_matrix_with_vector<Obtype, rb_RealMatrixColumn>(self, rb_other);
		} else {
			divide_warning_compatibility<Obtype>();
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		if (RARRAY_LEN(rb_other) > 0 && TYPE(rb_ary_entry(rb_other, 0)) == T_ARRAY) {
			RealMatrix division_matrix = rb_ary_to_realmatrix(rb_other);
			Obtype *m;
			Data_Get_Struct(self, Obtype, m);
			if (m->getData()->size2() != division_matrix.size1()) {
				rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B rows (%lu) for division.", m->getData()->size2(), division_matrix.size1());
			}
			*(m->getData()) /= division_matrix;
			return self;
		} else if (RARRAY_LEN(rb_other) > 0) {
			RealVector vec = rb_ary_to_1d_realvector(rb_other);
			Obtype *m;
			Data_Get_Struct(self, Obtype, m);
			if (m->getData()->size2() != vec.size()) {
				rb_raise(rb_eArgError, "For matrix division A/B incompatible number of A columns (%lu) and B rows (%lu) for division.", m->getData()->size2(), vec.size());
			}
			*(m->getData()) /= shark::blas::repeat(vec, m->getData()->size1());
			return self;
		} else {
			rb_raise(rb_eArgError, "It is tough to divide by an empty %s since the computer's imagination is limited by the Kernel.", rb_obj_classname(self));
		}
	} else {
		divide_warning_compatibility<Obtype>();
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_length (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	VALUE size = rb_ary_new2(2);
	// number of rows
	rb_ary_store(size, 0, INT2FIX(m->getData()->size1()));
	// number of columns
	rb_ary_store(size, 1, INT2FIX(m->getData()->size2()));
	return size;
}

template<class Obtype>
VALUE method_matrix_transpose (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	return wrap_pointer<rb_RealMatrix>(
		rb_RealMatrix::rb_class(),
		new rb_RealMatrix(trans(*(m->getData())))
		);
}

template<class Obtype>
VALUE method_matrix_size1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size1());
}

template<class Obtype>
VALUE method_matrix_size2 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->size2());
}

template<class Obtype>
VALUE method_matrix_stride1 (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride1());
}

template<class Obtype>
VALUE method_matrix_stride2 (VALUE self) {
	Check_Type(index, T_FIXNUM); 
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return INT2FIX(m->getData()->stride2());
}

template<class Obtype>
VALUE method_matrix_get_row (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index);

	if (index < 0 && int(index + m->getData()->size2()) < 0)
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
	if (index >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));

	return wrap_pointer<rb_RealMatrixRow>(
		rb_RealMatrixRow::rb_class(),
		new rb_RealMatrixRow(m->getData(),
			index < 0 ?
				index + m->getData()->size2() :
				index
			)
		);
}

template<class Obtype>
VALUE method_matrix_get_column (VALUE self, VALUE rb_index) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	int index = NUM2INT(rb_index),
		neg_index = 0;

	if (index < neg_index && (index + int(m->getData()->size1()) < neg_index))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
	if (index >= int(m->getData()->size1()))
		rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));

	return wrap_pointer<rb_RealMatrixColumn>(
		rb_RealMatrixColumn::rb_class(),
		new rb_RealMatrixColumn(m->getData(),
			index < 0 ?
				index + m->getData()->size1() :
				index
			)
		);
	return Qnil;
}

template<class Obtype>
VALUE method_matrix_clear (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->clear();
	return self;
}

template<class Obtype>
VALUE method_matrix_fill (VALUE self, VALUE filling) {
	if (TYPE(filling) != T_FLOAT && TYPE(filling) != T_FIXNUM)
		rb_raise(rb_eArgError, "Can only fill %s with floats.", rb_obj_classname(self));
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);

	std::fill(m->getData()->storage(), m->getData()->storage()+(m->getData()->size1()*(m->getData()->size2())), NUM2DBL(filling));

	return self;
}

template<class Obtype>
VALUE method_matrix_query (int number_of_arguments, VALUE* ruby_arguments, VALUE self) {
	VALUE row, column;
	rb_scan_args(number_of_arguments, ruby_arguments, "11", &row, &column);
	if (column != Qnil && row != Qnil) {
		Check_Type(row, T_FIXNUM);
		Check_Type(column, T_FIXNUM);
		Obtype *m;
		Data_Get_Struct(self, Obtype, m);
		int neg_index = 0;
		if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
			rb_raise(rb_eArgError, "Can only access positive positions in %s", rb_obj_classname(self));
		if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
			rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
		return rb_float_new((*(m->getData()))(NUM2INT(row), NUM2INT(column)));
	} else {
		if (TYPE(row) == T_FIXNUM) {
			return method_matrix_get_row<Obtype>(self, row);
		} else if (row == Qnil && TYPE(column) == T_FIXNUM) {
			return method_matrix_get_column<Obtype>(self, column);
		} else {
			rb_raise(rb_eArgError, "Can only access %s using 1. [Fixnum, Fixnum], or 2. [Nil, Fixnum], or 3. [Fixnum].", rb_obj_classname(self));
		}
	}
}

template<class Obtype>
static void method_matrix_insert_row(Obtype *m, int _row, VALUE assignment) {
	int neg_index = 0;
	if (_row < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions.");
	if (_row >= int(m->getData()->size1()))
		rb_raise(rb_eArgError, "Out of range.");

	if (TYPE(assignment) == T_DATA) {
		if (CLASS_OF(assignment) == rb_RealVector::rb_class()) {
			rb_RealVector *v;
			Data_Get_Struct(assignment, rb_RealVector, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealVectorReference::rb_class()) {
			rb_RealVectorReference *v;
			Data_Get_Struct(assignment, rb_RealVectorReference, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealMatrixRow::rb_class()) {
			rb_RealMatrixRow *v;
			Data_Get_Struct(assignment, rb_RealMatrixRow, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealMatrixColumn::rb_class()) {
			rb_RealMatrixColumn *v;
			Data_Get_Struct(assignment, rb_RealMatrixColumn, v);
			row(*(m->getData()), _row) = *(v->getData());
		} else {
			rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
		}
	} else if (TYPE(assignment) == T_ARRAY) {
		if (RARRAY_LEN(assignment) != m->getData()->size2())
			rb_raise(rb_eArgError, "Can only assign a new row of equal size to previous row length.");
		if (RARRAY_LEN(assignment) > 0) {
			if (TYPE(rb_ary_entry(assignment, 0)) != T_FIXNUM && TYPE(rb_ary_entry(assignment, 0)) != T_FLOAT)
				rb_raise(rb_eArgError, "Can only insert floats.");
			RealVector vec = rb_ary_to_1d_realvector(assignment);
			row(*(m->getData()), _row) = vec;
		}
	} else {
		rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
	}
}

template<class Obtype>
static void method_matrix_insert_column (Obtype *m, int col, VALUE assignment) {
	int neg_index = 0;
	if (col < neg_index)
		rb_raise(rb_eArgError, "Can only access positive positions.");
	if (col >= int(m->getData()->size2()))
		rb_raise(rb_eArgError, "Out of range.");


	if (TYPE(assignment) == T_DATA) {
		if (CLASS_OF(assignment) == rb_RealVector::rb_class()) {
			rb_RealVector *v;
			Data_Get_Struct(assignment, rb_RealVector, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealVectorReference::rb_class()) {
			rb_RealVectorReference *v;
			Data_Get_Struct(assignment, rb_RealVectorReference, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealMatrixRow::rb_class()) {
			rb_RealMatrixRow *v;
			Data_Get_Struct(assignment, rb_RealMatrixRow, v);
			column(*(m->getData()), col) = *(v->getData());
		} else if (CLASS_OF(assignment) == rb_RealMatrixColumn::rb_class()) {
			rb_RealMatrixColumn *v;
			Data_Get_Struct(assignment, rb_RealMatrixColumn, v);
			column(*(m->getData()), col) = *(v->getData());
		} else {
			rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
		}
	} else if (TYPE(assignment) == T_ARRAY) {
		if (RARRAY_LEN(assignment) != int(m->getData()->size1()))
			rb_raise(rb_eArgError, "Can only insert a new column of equal size to previous column length.");
		if (RARRAY_LEN(assignment) > 0) {
			if (TYPE(rb_ary_entry(assignment, 0)) != T_FIXNUM && TYPE(rb_ary_entry(assignment, 0)) != T_FLOAT)
				rb_raise(rb_eArgError, "Can only insert floats.");
			RealVector vec = rb_ary_to_1d_realvector(assignment);
			column(*(m->getData()), col) = vec;
		}
	} else {
		rb_raise(rb_eArgError, "Can only insert RealVector/Array/RealMatrixRow/RealMatrixColumn.");
	}
}

template<class Obtype>
VALUE method_matrix_insert (int number_of_arguments, VALUE* ruby_arguments, VALUE self) {
	VALUE row, column, assignment;

	rb_scan_args(number_of_arguments, ruby_arguments, "21", &row, &column, &assignment);

	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	if (assignment != Qnil && row != Qnil) {
		Check_Type(row, T_FIXNUM);
		Check_Type(column, T_FIXNUM);
		if (TYPE(assignment) != T_FIXNUM && TYPE(assignment) != T_FLOAT)
			rb_raise(rb_eArgError, "Can only insert floats into %s.", rb_obj_classname(self));
		int neg_index = 0;
		if (NUM2INT(row) < neg_index || NUM2INT(column) < neg_index)
			rb_raise(rb_eArgError, "Can only access positive positions in %s", rb_obj_classname(self));
		if (NUM2INT(row) >= int(m->getData()->size1()) || NUM2INT(column) >= int(m->getData()->size2()))
			rb_raise(rb_eArgError, "Out of range of %s", rb_obj_classname(self));
		(*(m->getData()))(NUM2INT(row), NUM2INT(column)) = NUM2DBL(assignment);
	} else {
		// assigning a row or column.
		if (TYPE(row) == T_FIXNUM && column != Qnil && assignment == Qnil) {
			method_matrix_insert_row<Obtype>(m, NUM2INT(row), column);
		} else if (row == Qnil && TYPE(column) == T_FIXNUM && assignment != Qnil) {
			method_matrix_insert_column<Obtype>(m, NUM2INT(column), assignment);
		} else {
			rb_raise(rb_eArgError, "Can only make assignments using:\\\t1. [Fixnum, Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn] or\\\t2.[Nil, Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn], or\\\t3.[Fixnum]=[RealVector/Array/RealMatrixRow/RealMatrixColumn],\\with  %s.", rb_obj_classname(self));
		}
	}
	return self;
}

template<class Obtype>
VALUE method_matrix_resize (VALUE self, VALUE newRows, VALUE newColumns) {
	Check_Type(newRows, T_FIXNUM);
	Check_Type(newColumns, T_FIXNUM);
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	m->getData()->resize(NUM2INT(newRows), NUM2INT(newColumns));
	return self;
}

template<class Obtype>
VALUE method_matrix_negate (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	return wrap_pointer<rb_RealMatrix>(
		rb_RealMatrix::rb_class(),
		new rb_RealMatrix(-*(m->getData()))
	);
}

template<class Obtype>
VALUE method_matrix_to_rows (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	//std::vector<rb_RealMatrixRow> vectors = realmatrix_to_stdvector_realvector(m->getData());
	VALUE ary = rb_ary_new2(int(m->getData()->size1()));
	for (size_t i=0; i< m->getData()->size1(); i++) {
		rb_ary_store(ary, (int)i, wrap_pointer<rb_RealMatrixRow>(
			rb_RealMatrixRow::rb_class(),
			new rb_RealMatrixRow(m->getData(), i)
		));
	}
	return ary;
}

template<class Obtype>
VALUE method_matrix_to_columns (VALUE self) {
	Obtype *m;
	Data_Get_Struct(self, Obtype, m);
	//std::vector<rb_RealMatrixRow> vectors = realmatrix_to_stdvector_realvector(m->getData());
	VALUE ary = rb_ary_new2(int(m->getData()->size2()));
	for (size_t i=0; i< m->getData()->size2(); i++) {
		rb_ary_store(ary, (int)i, wrap_pointer<rb_RealMatrixColumn>(
			rb_RealMatrixColumn::rb_class(),
			new rb_RealMatrixColumn(m->getData(), i)
		));
	}
	return ary;
}

template<class Obtype, class OtherObtype>
VALUE method_matrix_compare(VALUE left, VALUE right) {
	Obtype *v;
	OtherObtype *other_v;
	Data_Get_Struct(left, Obtype, v);
	Data_Get_Struct(right, OtherObtype, other_v);
	// check size
	if (other_v->getData()->size1() != v->getData()->size1() || other_v->getData()->size2() != v->getData()->size2())
		return Qfalse;
	// check each element... can parallelize this.
	for (size_t i = 0; i<v->getData()->size1(); i++)
		for (size_t j = 0; j<v->getData()->size2(); j++)
			if ((*(other_v->getData()))(i,j) != (*(v->getData()))(i,j))
				return Qfalse;
	return Qtrue;
}

template<class Obtype>
VALUE method_matrix_soft_eql(VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		VALUE other_class = CLASS_OF(rb_other);
		if (other_class == rb_RealMatrix::rb_class()) {
			return method_matrix_compare<Obtype, rb_RealMatrix>(self, rb_other);
		} else if (other_class == rb_RealVectorReference::rb_class()) {
			return method_matrix_compare<Obtype, rb_RealMatrixReference>(self, rb_other);
		} else {
			return Qfalse;
		}
	} else if (TYPE(rb_other) == T_ARRAY) {
		VALUE self_ary = method_matrix_to_ary<Obtype>(self);
		return rb_funcall(self_ary, rb_intern("=="), 1, rb_other);
	} else {
		return Qfalse;
	}
}

template<class Obtype>
VALUE method_matrix_eql(VALUE self, VALUE rb_other) {
	if (TYPE(rb_other) == T_DATA) {
		if (CLASS_OF(rb_other) != CLASS_OF(self))
			return Qfalse;
		return method_matrix_compare<Obtype, Obtype>(self, rb_other);
	} else {
		return Qfalse;
	}
}

template<class Obtype>
void Init_MatrixMethods () {
	Init_DatatypeDeepCopy<Obtype, rb_RealMatrix>();
	rb_define_method(Obtype::rb_class(), "inverse", (rb_method)method_matrix_get_inverse<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "sum", (rb_method)method_matrix_get_sum<Obtype>, -1);
	rb_define_method(Obtype::rb_class(), "mean", (rb_method)method_matrix_get_mean<Obtype>,-1);
	rb_define_method(Obtype::rb_class(), "round", (rb_method)method_matrix_get_rounded<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "max", (rb_method)method_matrix_get_max<Obtype>,-1);
	rb_define_method(Obtype::rb_class(), "min", (rb_method)method_matrix_get_min<Obtype>,-1);
	rb_define_method(Obtype::rb_class(), "exp", (rb_method)method_matrix_get_exp<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "log", (rb_method)method_matrix_get_log<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "sqrt", (rb_method)method_matrix_get_sqrt<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "to_a", (rb_method)method_matrix_to_ary<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "each", (rb_method) method_matrix_each<Obtype>, 0);
	rb_define_alias(Obtype::rb_class(), "each_row", "each");
	rb_define_method(Obtype::rb_class(), "each_column", (rb_method) method_matrix_each_column<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "each_with_index", (rb_method) method_matrix_each_with_index<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "to_matrix", (rb_method)method_matrix_to_matrix<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "rows", (rb_method)method_matrix_to_rows<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "columns", (rb_method)method_matrix_to_columns<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "to_unlabeleddata", (rb_method)method_matrix_to_unlabeleddata<Obtype>,0);
	rb_define_alias(Obtype::rb_class(), "to_unlabeled_data", "to_unlabeleddata");
	rb_define_method(Obtype::rb_class(), "cols", (rb_method)method_matrix_to_columns<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "*", (rb_method)method_matrix_multiply<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "**", (rb_method)method_matrix_get_pow<Obtype>, 1);
	rb_define_alias(Obtype::rb_class(), "power", "**");
	rb_define_alias(Obtype::rb_class(), "pow", "**");
	rb_define_method(Obtype::rb_class(), "o", (rb_method) method_matrix_hadamard_product<Obtype>, 1);
	rb_define_alias(Obtype::rb_class(), "hadamard", "o");
	rb_define_alias(Obtype::rb_class(), "element_wise_product", "o");
	rb_define_method(Obtype::rb_class(), "o=", (rb_method) method_matrix_hadamard_product_equals<Obtype>, 1);
	rb_define_alias(Obtype::rb_class(), "hadamard=", "o=");
	rb_define_alias(Obtype::rb_class(), "element_wise_product=", "o=");
	rb_define_method(Obtype::rb_class(), "*=", (rb_method)method_matrix_multiply_equals<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "/=", (rb_method)method_matrix_divide_equals<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "/", (rb_method)method_matrix_divide<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "+", (rb_method)method_matrix_add<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "+=", (rb_method)method_matrix_add_equals<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "-", (rb_method)method_matrix_subtract<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "-=", (rb_method)method_matrix_subtract_equals<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "length", (rb_method)method_matrix_length<Obtype>, 0);
	rb_define_alias(Obtype::rb_class(), "size", "length");
	rb_define_method(Obtype::rb_class(), "==", (rb_method) method_matrix_soft_eql<Obtype>,1);
	rb_define_method(Obtype::rb_class(), "eql?", (rb_method) method_matrix_eql<Obtype>,1);
	rb_define_method(Obtype::rb_class(), "transpose", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "~", (rb_method)method_matrix_transpose<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "size1", (rb_method)method_matrix_size1<Obtype>, 0);
	rb_define_alias(Obtype::rb_class(), "number_of_rows", "size1");
	rb_define_method(Obtype::rb_class(), "size2", (rb_method)method_matrix_size2<Obtype>, 0);
	rb_define_alias(Obtype::rb_class(), "number_of_columns", "size2");
	rb_define_method(Obtype::rb_class(), "stride1", (rb_method)method_matrix_stride1<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "stride2", (rb_method)method_matrix_stride2<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "row", (rb_method)method_matrix_get_row<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "column", (rb_method)method_matrix_get_column<Obtype>, 1);
	rb_define_alias(Obtype::rb_class(), "col", "column");
	rb_define_method(Obtype::rb_class(), "fill", (rb_method)method_matrix_fill<Obtype>, 1);
	rb_define_method(Obtype::rb_class(), "clear", (rb_method)method_matrix_clear<Obtype>, 0);
	rb_define_method(Obtype::rb_class(), "-@", (rb_method)method_matrix_negate<Obtype>,0);
	rb_define_method(Obtype::rb_class(), "[]", (rb_method)method_matrix_query<Obtype>,-1);
	rb_define_method(Obtype::rb_class(), "resize", (rb_method)method_matrix_resize<Obtype>, 2);
	rb_define_method(Obtype::rb_class(), "[]=", (rb_method)method_matrix_insert<Obtype>,-1);

}